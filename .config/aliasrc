#!/bin/bash

# general Aliases
alias tmux="tmux -2"                                # launch tmux with 256 color
command -v rsync &> /dev/null && alias cp="cpv -iv" # use rsync instead of cp if installed
alias mv="mv -iv"                                   # ask before overwrite and verbose output for mv
alias rm="rm -v"                                    # verbose output for rm
alias ip="ip -c"                                    # enable colors for ip
alias srm="shred -u -n 1"                           # shred and deallocate file
# use exa instead of ls if installed
command -v exa &> /dev/null && { alias l="exa -lahg --icons --octal-permissions" && alias ll="exa -lhg --icons --octal-permissions"; }
# alias lf to ranger if not installed
command -v lf &> /dev/null || alias lf="ranger"

# quickly sync git repo
alias gsync="git pull && git add . && git commit -am 'Update' && git push"

# clipboard aliases
command -v xclip > /dev/null && { alias setclip="xclip -selection c" && alias getclip="xclip -selection c -o"; }
command -v wl-copy > /dev/null && { alias setclip="wl-copy" && alias getclip="wl-paste"; }

# function to automatically update dotfiles
updaterc() {
    pwd="$(pwd)"
    cd ~/.dotfiles || {
        echo 'The .dotfiles folder should be at ~/.dotfiles to auto update'
        return 1
    }
    git pull
    ./install.sh only-link
    cd "$pwd" || return 1
}

# print input in fancy way
upd_announce() {
    GREEN='\033[0;32m'
    NC='\033[0m'
    echo -e "${GREEN}>>> $*${NC}"
}

# update all the things
upd() {
    # update dotfiles
    upd_announce Updating dotfiles
    updaterc || return 1
    upd_announce done!

    # update nvim stuff
    command -v nvim &> /dev/null && {
        upd_announce Updating nvim packer packages
        nvim --headless -c 'autocmd User PackerComplete quitall' -c 'PackerSync' || return 1
        upd_announce done!
        upd_announce Updating nvim mason packages
        nvim --headless -c 'autocmd User MasonUpdateAllComplete quitall' -c 'MasonUpdateAll' || return 1
        upd_announce done!
    }

    # update flatpaks
    command -v flatpak $ > /dev/null && {
        upd_announce Updating flatpaks
        flatpak update || return 1
        upd_announce done!
    }

    # refresh gpg keyring
    gpg --list-keys &> /dev/null && {
        upd_announce Updating gpg keyring
        gpg --keyserver keyserver.ubuntu.com --refresh-keys || return 1
        upd_announce done!
    }

    # rust toolchain(s)
    command -v rustup &> /dev/null && {
        upd_announce Updating rust toolchain
        rustup update || return 1
        upd_announce done!
    }

    # cargo packages
    command -v cargo &> /dev/null && {
        upd_announce Updating cargo packages
        cargo_pkg_list=()
        while IFS='' read -r line; do cargo_pkg_list+=("$line"); done < <(cargo install --list | grep -E '^[a-z0-9_-]+ v[0-9.]+:$' | cut -f1 -d' ')
        if [ "${#cargo_pkg_list[@]}" -ne 0 ]; then
            cargo install "${cargo_pkg_list[@]}" || return 1
        fi
        unset cargo_pkg_list
        upd_announce done!
    }
}

colortest() {
    awk 'BEGIN{
        s="/\\/\\/\\/\\/\\"; s=s s s s s s s s;
        for (colnum = 0; colnum<77; colnum++) {
            r = 255-(colnum*255/76);
            g = (colnum*510/76);
            b = (colnum*255/76);
            if (g>255) g = 510-g;
            printf "\033[48;2;%d;%d;%dm", r,g,b;
            printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
            printf "%s\033[0m", substr(s,colnum+1,1);
        }
        printf "\n";
    }'
}

# print public ip address
pubip() {
    curl ipinfo.io/ip && echo
}

# Quickly generate a password from /dev/urandom
pwgen() {
    if [ -z "${1}" ]; then
        _PWLENGTH=20
    else
        _PWLENGTH="$1"
    fi
    tr -dc _\!\"\%\&\/\(\)\=A-Z-a-z-0-9 < /dev/urandom | head -c "$_PWLENGTH"
    echo
    unset _PWLENGTH
}

# jump to directory using lf
lfcd() {
    tmp="$(mktemp -uq)"
    trap 'rm -f $tmp >/dev/null 2>&1' HUP INT QUIT TERM PWR EXIT
    lf -last-dir-path="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        # shellcheck disable=SC2164
        [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir"
    fi
}

# convert code file to pdf using pandoc
# TODO rewrite
code2pdf() {
    echo "LS0tCmhlYWRlci1pbmNsdWRlczoKIC0gXHVzZXBhY2thZ2V7ZnZleHRyYX0KIC0gXERlZmluZVZlcmJhdGltRW52aXJvbm1lbnR7SGlnaGxpZ2h0aW5nfXtWZXJiYXRpbX17YnJlYWtsaW5lcyxjb21tYW5kY2hhcnM9XFxce1x9fQotLS0=" | base64 -d \
        > "$(echo $1 | grep ".*\." --only-matching)md"
    echo "\n\`\`\`$(echo $1 | grep -E "\.\w+" --only-matching | sed "s/\.//g")\n$(cat $1)\n\`\`\`" \
        >> "$(echo $1 | grep ".*\." --only-matching)md"
    pandoc "$(echo $1 | grep ".*\." --only-matching)md" --pdf-engine=xelatex -s -V geometry:margin=2cm -o \
        "$(echo $1 | grep ".*\." --only-matching)pdf"
    rm "$(echo $1 | grep ".*\." --only-matching)md" > /dev/null
}

# Convert xournalpp file to pdf
xconvert() {
    xournalpp -p "$(basename "$1" .xopp)_x.pdf" "$1"
}

# Convert all xopp files in current directory to pdf
xconvertall() {
    for file in ./*.xopp; do xconvert "$file"; done
}

# Compile and run c program
crun() {
    gcc -g -DDEBUG -Wall -Wextra -pedantic -std=c17 -o "$(basename "$1" .c).out" "$1" && ./"$(basename "$1" .c).out"
}
